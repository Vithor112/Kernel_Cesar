;
;
;******************************************************************************
;
;	Arquivo de Referência para o desenvolvimento do kernel.
;
;	Versão: 2021.1
;
;	Áreas de memória
;
;	0000 - 7FFF		_KERNEL
;					Área de Kernel para implementação dos alunos
;
;	0100 - 01FF		_VETTAB
;					Tabela com os vetores das funções do kernel
;					*** CUIDADO! Esse vetor está no meio da área de código ***
;
;	8000 - FF7F		_APP
;					Área onde será colocado o programa de aplicação.
;					Esse programa vai fazer o acesso aos periféricos e interrupções, através das funções do Kernel.
;
;	FF80 - FFBF 	_IOAREA16
;					Area de perifericos, acessada na base 16 bits
;
;	FFC0 - FFFF		_IOAREA08
;					Area de perifericos, acessada na base 8 bits
;					
;******************************************************************************


_KERNEL:	equ	h0000
_VETTAB:	equ	h0100
_APP:		equ	h8000
_IOAREA16:	equ	hFF80
_IOAREA08:	equ	hFFC0


;
;------------------------------------------------------------------------------
;	Área reservada para os periféricos
;------------------------------------------------------------------------------

; Acesso em 16 bits
		org		_IOAREA16
		daw		[31]
IVET:	dw		0			; Vetor de interrupção

; Acesso em 8 bits
		org		_IOAREA08
		dab		[23]
TIMDT:	db		0			; Registro de programação do timer
INTS:	db		0			; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db		0			; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim
TECST:	db		0			; Status do teclado
TECDT:	db		0			; Dado do teclado
VISOR:	dab		[36]		; Portas de acesso ao visor

;	
;------------------------------------------------------------------------------
;	Ponto de entrada do RESET do processador
;------------------------------------------------------------------------------
		org		_KERNEL
		jmp		_RESET

;
;------------------------------------------------------------------------------
;	Area do kernel com os vetores das funções do kernel
;------------------------------------------------------------------------------
		org		_VETTAB
		dw		_kbhit
		dw		_getchar
		dw		_putchar
		dw		_get_clock_status
		dw		_get_clock_time
		dw		_turnon_clock
		dw		_clr_clock
		
;	
;------------------------------------------------------------------------------
;	Código de RESET (BOOT) do processador/interrupção
;------------------------------------------------------------------------------
org		_VETTAB+h0100
; 1) Desabilitar o sistema de interrupções
_RESET:	clr INTE
; 2) Inicializar o stack pointer (SP = R6)
	 mov #H7FFF, R6 
; 3) Inicializar as variáveis internas usadas pelo sistema de interrupções e periféricos (IVET, INTE, etc.)
	mov #isr, IVET
	clr INTS
; 4) Inicializar as variáveis internas do kernel
	mov #-1, bufferTec
	mov #0, posCursor
	mov #0, blinkCursor
; 5) Inicializar o teclado zerando o byte de estado (TECST, endereço 65498)
	clr TECST
; 6) Inicializar o timer
	clr TIMDT
; 7) Limpar o visor
	jsr r7, limpavisor
; 8) Habilitar interrupções
	mov #h83, INTE
; 9) Retornar para o programa de aplicação com um desvio para o endereço _APP da memória
	jmp		_APP

;------------------------------------------------------------------------------
; VARIÁVEIS  VARIÁVEIS  VARIÁVEIS  VARIÁVEIS  VARIÁVEIS  VARIÁVEIS  VARIÁVEIS  
;------------------------------------------------------------------------------
	org 800 
		auxTime: dw  0		 ;; armazena os milisegundos	
		bufferTec: dw 0 	;; armazena a tecla lida pelo ISR
		timer: dw 0 		;; armazena os segundos
		posCursor: dw 0 	;; armazena posição do cursor
		charCursor: dw  0 	;; armazena o caracter atual do cursor
		blinkCursor: dw  0 	;; Variavel booleana para trocar de char no cursor ( getchar )
;------------------------------------------------------------------------------
; INTERRUPÇAO INTERRUPCAO INTERRUPCAO INTERRUPCAO INTERRUPCAO INTERRUPCAO 
;------------------------------------------------------------------------------


org 900
ISR:
		mov		r0,-(r6)	; Salva registradores
		mov		r1,-(r6)
		mov		r2,-(r6)
		mov		r3,-(r6)
		mov		r4,-(r6)
		mov		r5,-(r6)

		mov		INTS,r0		; Verifica se é INT do TECLADO
		and		#2,r0
		beq		ISR2
		jsr		r7,ISRtec	; Tratamento da INT do TECLADO
		and		#hFFFD,INTS	; Desliga bit de INT TECLADO
ISR2:		mov		INTS,r0		; Verifica se é INT do TIMER
		and		#1,r0
		beq		ISR3
		jsr		r7,ISRtim	; Tratamento da INT do TIMER
		and		#hFFFE,INTS	; Desliga bit de INT TIMER
ISR3:

		mov		(r6)+,r5	; Retorna os registradores da pilha
		mov		(r6)+,r4
		mov		(r6)+,r3
		mov		(r6)+,r2
		mov		(r6)+,r1
		mov		(r6)+,r0

		rti					; Return From Interrupt


; Tratamento das interrupções de teclado
ISRtec:
		tst		TECST				; if (Tecla está disponivel?) {
		beq		ISRtec1
		mov 		TECDT, bufferTec
		clr 		TECST		

	
ISRtec1:	
		rts	r7						; }
		

ISRtim:		
		jsr r7, tratador
		
		rts r7

tratador: 	INC auxTime
		tst blinkCursor		;; Verifica se a variável booleana blinkCursor está ligada
		BEQ pulaBlink
		jsr r7, piscaCursor
pulaBlink:	cmp auxTime, #10
		BNE not_equal
		mov #0, auxTime
		INC timer
		not_equal: rts r7
		
;------------------------------------------------------------------------------
; CURSOR CURSOR CURSOR CURSOR CURSOR CURSOR CURSOR CURSOR CURSOR CURSOR CURSOR 
; Parâmetros: Posição nova do cursor em r4
; Atualiza a função do cursor
;------------------------------------------------------------------------------

cursor:		tst r4
		BMI end_cursor		;; Se for negativo, valor inválido, não mexe
		cmp r4, #21		;; Se maior que 21, fora da área de texto, não mexe
		BGT end_cursor
		mov r4, posCursor
end_cursor: 	rts r7

;-------------------------------------------------------------------------------------
; PISCACURSOR PISCACURSOR PISCACURSOR PISCACURSOR PISCACURSOR PISCACURSOR PISCACURSOR
; Faz com que o cursor pisque, alterando entre '_' e o caracter atual do visor a uma
; taxa de 500ms, quem chama essa função é o sistema de interrupção do timer
;-------------------------------------------------------------------------------------
piscaCursor:	
		cmp auxTime, #5		;; Verifica se passou 500ms 
		BEQ pisca
		cmp auxTime, #0
		BNE end_piscaCursor	
pisca:		mov charCursor, r4	;; Troca o caracter no visor por _ ou pelo caracter que estava no visor ( tirando o _ da tela )
		mov posCursor, r3
		mov 65500(r3), charCursor
		mov posCursor, r3
		mov r4, 65500(r3)
end_piscaCursor:rts r7
		
		
;------------------------------------------------------------------------------
; Função através da qual pode-se solicitar ao kernel a informação sobre a existência de tecla digitada.
; A função deve retornar com a informação da existência de tecla, sem aguardar pela digitação de qualquer tecla. 
; - Parâmetros de entrada: nenhum. 
; - Parâmetro de saída: registrador R0, com a informação da existência de tecla. 
; A função retorna no registrador R0 a informação se existe tecla ou não. 
; - Se há tecla, o valor em R0 será zero; 
; - Se não há tecla, o valor em R0 será um valor qualquer diferente de zero. 
;------------------------------------------------------------------------------
_kbhit:		mov		#1, r0
		tst		bufferTec	 ;; Verificar se é positivo ou nulo
		BMI 		kbhit_ret
		cmp 		bufferTec, #127 ;; Verificar se está dentro da tabela ASCII
		BGT		kbhit_ret
		mov		#0, r0 		 ;; Se passar nas 2 verificações, é uma tecla. 
kbhit_ret:	rts		r7
		
;		
;------------------------------------------------------------------------------
; Função através da qual pode-se solicitar ao kernel que aguarde pela digitação de uma tecla.
; A função deve retornar o código ASCII da tecla digitada.
; Portanto, a função deve aguardar pela digitação de uma tecla. 
; - Parâmetros de entrada: nenhum. 
; - Parâmetro de saída: registrador R0, com a tecla digitada. 
; A função só retorna (só termina) quando o usuário digitar alguma tecla.
; O código ASCII da tecla digitada deve ser retornado no registrador R0. 
; Sempre que a função “_getchar” for chamada e estiver bloqueada aguardando por uma tecla,
;     a posição do cursor deve ser apresentado no visor através do símbolo “_” (underscore).
; Esse símbolo deve ser alternado com o caractere que estiver sendo apresentado nessa posição.
; Essa alternância deve ter uma periodicidade tal que cada símbolo permaneça no visor por 500ms. 
;------------------------------------------------------------------------------
_getchar:	
		mov r3,-(r6) 		;; Salva Registrador usado
		mov #-1, bufferTec 	;; Limpando o buffer
		mov #95, charCursor 	;; inicializando
		mov #1, blinkCursor 	;; Liga a função que piscaCursor
loop_getchar:	jsr r7,_kbhit  		;; Verificando se há tecla
		tst r0
		BNE loop_getchar
		mov #0, blinkCursor	;; Desliga a função que pisca cursor
		cmp charCursor, #95	;; Caso '_' esteja na tela quando a função parou
		BEQ end_getchar
		mov posCursor, r3	;; Tira-o da tela e coloca o char que estava ali
		mov charCursor, 65500(r3) 
end_getchar:	mov bufferTec, r0   	;; Movendo a tecla para r0	
		mov (r6)+, r3		;; Carrega Registrador usado
		rts		r7
		
;		
;------------------------------------------------------------------------------
; Envia um caractere ASCII para o visor.
; Esse caractere pode ser um caractere visível ou um caractere de controle. 
; - Parâmetros de entrada: registrador R5, com o caractere a ser colocado no visor. 
; - Parâmetro de saída: registrador R0, com o código de erro de retorno. 
; O código no registrador R5 pode representar caracteres visíveis ou caracteres de controle. 
; Na inicialização do kernel, o visor deve ser limpo (apagado) e o cursor deve ser posicionado no início do visor. 
; A função retorna no registrador R0 um código de erro. 
; - Se não houve erro, o valor em R0 será zero; 
; - Se houve algum erro ou informação inválida de entrada, o valor em R0 será um valor qualquer diferente de zero. 
;------------------------------------------------------------------------------
_putchar:
		mov		r4,-(r6)		;; Salva Registrador usado
		and 		#h81,INTE		;; Desliga as interrupções de teclado ( pois vou usar Buffertec por alguns momentinhos
		mov		r5, bufferTec		;; Move para o bufferTec (para chamar kbhit)
		jsr 		r7, _kbhit		;; Chama kbhit para verificar a tecla
		mov		#h83, INTE		;; Liga as interrupções de teclado
		tst 		r0			;; Se r0 != 0 então tecla inválida termina putchar
		BNE		end_putchar		
		cmp		r5, #h0d		;; Se tecla == carriage return, vai pro tratamento especial
		BEQ		carriage_ret
		cmp		r5, #h08		;; Se tecla == backspace, vai pro tratamento especial
		BEQ 		backSpace_ret
		cmp		r5,#h7a			;; Se tecla maior que h7a então tecla inválida (Kbhit considera válido até h7f )
		BGT		end_putchar
		mov		poscursor, r4		
		mov		r5, 65500(r4)		;; Coloca tecla na atual posição do cursor
		add		#1, r4			;; Soma um a posiçao do cursor e a atualiza chamando a função cursor
		jsr		r7,cursor
		mov 		(r6)+,r4		;; Resgata registrador
		rts 		r7


end_putchar:	mov 		#1, r0			;; Código de erro!
		mov 		(r6)+,r4		;; Resgata registrador
		rts 		r7

backSpace_ret:	mov		posCursor,r4
		sub		#1, r4			;; Subtrai um da posição do cursor e a atualiza!
		jsr 		r7,cursor
		mov 		(r6)+,r4		;; Resgata registrador
		rts 		r7

carriage_ret:	mov 		#0,r4			;; Zera a posição do cursor!
		jsr 		r7,cursor
		mov 		(r6)+,r4		;; Resgata registrador
		rts		r7
		
;		
;------------------------------------------------------------------------------
; Essa função fornece as informações relativas à situação atual de cada relógio, 
; no que diz respeito à sua visibilidade e se está andando. 
; - Parâmetros de entrada: registrador R5, com o identificador do relógio a ser lido.
;   Esse valor pode ser 0 (zero) ou 1 (um). 
; Outros valores devem ser ignorados. 
; - Parâmetro de saída: registrador R0, com a indicação do estado do relógio (visibilidade e se está parado). 
; No retorno da função, o registrador R0 conterá as informações do estado do relógio em seus bits 0 e bit 1. 
; O bit 0, quando ligado (valor “1”), indica que o relógio está visível;
; O bit 1, quando ligado (valor “1”), indica que o relógio está andando. 
;------------------------------------------------------------------------------
_get_clock_status:
		rts		r7
	
;		
;------------------------------------------------------------------------------
; Essa função fornece o valor atual de cada relógio.
; Essa informação é fornecida como um número inteiro de segundos.
; Como cada relógio tem minutos e segundos,
;     o valor fornecido deverá ser o resultado da aplicação da seguinte fórula (60*MIN+SEG). 
; - Parâmetros de entrada: registrador R5, com o identificador do relógio a ser lido.
;   Esse valor pode ser 0 (zero) ou 1 (um). Outros valores devem ser ignorados. 
; - Parâmetro de saída: registrador R0, com o número de segundos atualmente presentes no relógio. 
; No retorno da função, o registrador R0 conterá o número de segundos correspondentes à informação atual no relógio.
; Essa informação corresponde àquela presente no relógio, independentemente de seu estado (visível/invisível ou parado/andando). 
;------------------------------------------------------------------------------
_get_clock_time:
		rts		r7
		
;		
;------------------------------------------------------------------------------
; Essa função é usada para indicar ao kernel se o relógio deve “andar” ou “parar”.  
; - Parâmetros de entrada: 
;   - registrador R5, com o identificador do relógio a ser ativado/desativado.
;     Esse valor pode ser 0 (zero) ou 1 (um). Outros valores devem ser ignorados; 
;   - registrador R4, com a indicação do estado a ser colocado o relógio.
;     Esse valor pode ser 0 (zero), caso o relógio deva parar,
;     ou um valor diferente de 0 (zero), caso o relógio deva andar. 
; - Parâmetro de saída: registrador R0, com o código de erro de retorno. 
; A função retorna no registrador R0 um código de erro. 
; - Se não houve erro, o valor em R0 será zero; 
; - Se houve algum erro ou informação inválida de entrada,
;   o valor em R0 será um valor qualquer diferente de zero. 
;------------------------------------------------------------------------------
_turnon_clock:
		rts		r7
		
;		
;------------------------------------------------------------------------------
; Essa função é usada para indicar ao kernel que o relógio deve ser zerado.
; Ou seja, minutos e horas armazenado no relógio devem ser zerados. 
; - Parâmetros de entrada: registrador R5, com o identificador do relógio a ser zerado.
;   Esse valor pode ser 0 (zero) ou  1 (um). Outros valores devem ser ignorados; 
; - Parâmetro de saída: registrador R0, com o código de erro de retorno. 
; A função retorna no registrador R0 um código de erro. 
; - Se não houve erro, o valor em R0 será zero; 
; - Se houve algum erro ou informação inválida de entrada,
;          o valor em R0 será um valor qualquer diferente de zero. 
;------------------------------------------------------------------------------
_clr_clock:
		rts		r7

;------------------------------------------------------------------------------
; LIMPAVISOR LIMPAVISOR LIMPAVISOR LIMPAVISOR LIMPAVISOR LIMPAVISOR LIMPAVISOR 
;------------------------------------------------------------------------------
; Limpa o visor, forma mais eficiente de fazer isso segundo o livro Fundamentos de arquitetura de computadores  do professor Raul Weber
limpavisor: 
	CLR 65500
	CLR 65501
	CLR 65502 
	CLR 65503 
	CLR 65504 
	CLR 65505 
	CLR 65506 
	CLR 65507 
	CLR 65508 
	CLR 65509 
	CLR 65510 
	CLR 65511 	
	CLR 65512 
	CLR 65513 
	CLR 65514 
	CLR 65515 
	CLR 65516 
	CLR 65517 
	CLR 65518 
	CLR 65519 
	CLR 65520 
	CLR 65521 
	CLR 65522 
	CLR 65523 
	CLR 65524
	CLR 65525 
	   CLR 65526 
	CLR 65527 
	CLR 65528 
	CLR 65529 
	CLR 65530 
	CLR 65531 
	CLR 65532 
	CLR 65533 
	CLR 65534 
	CLR 65535 
	RTS R7


org _APP	
		mov #10, r4
		mov #10, r2
		mov #10, r3
		clr r1
vol:		add #1, r1
		mov #49,r5
		jsr r7,	_putchar
		cmp r1, #5
		blt vol
		jsr r7, _getchar
		hlt

